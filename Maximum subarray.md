# 最大子序列

## 问题描述

想象有这样一个天上掉下来的馅饼：你能够预知未来股市的价格走势，但是你只能进行一次交易。显然你的目标就是利用这一信息优势使这一次交易的收益最大，这实施起来也并不困难，只需要找到价格序列的最小值和最大值对应的日期就好了，在最低点买进，最高点卖出。

## 算法及其原理

首先，最容易想到的，也是最暴力的求解方法就是用两个循环遍历。

```python
from itertools import product
max_return = 0
low = 0
high = 0
for i,j in product(range(len(a)),range(len(a))):
        if j > i:
            if a[j] - a[i] > max_return:
                max_return = a[j] - a[i]
                low = i
                high = j
```
这种做法的复杂度高达 $O(n^2)$, 我们可以考虑用分治法来降低复杂度。对于任何一个序列，将其（近似）等分为二，那么我们所求的最低点与最高点一定处于下面三种情形之一：

- 全部位于第一个子序列
- 全部位于第二个子序列
- 最低点位于第一个子序列，最高点位于第二个子序列

如果我们能分别求出三种情形下的最大收益，然后比较之就能得到最终解。而对于前两种情形，则是完全和原问题一样，只是具有一半的规模。根据递归方法复杂度公式，分割与合并操作的复杂度均为常数，第三种情形由于原序列中点一定在最低点和最高点之间，所以只需要分别对第一个子序列和第二个子序列各进行一层循环遍历即可，最终的复杂度为 $O(n)$，其中 $n$ 为原序列的长度。所以最终时间复杂度递推公式为 $T(n)=2T(n/2)+O(n)+O(1)$。根据主定理，该算法的复杂度为 $O(n\lg n)$。

具体来讲，函数能够返回序列最低点和最高点的索引及其最大收益。假设序列起点为 `low`，终点为 `high`，那么终点 `mid` = (`low` + `high`) / 2，这样第一个子序列 `left` 的起点就是 `low`，终点就是 `mid`，第二个子序列 `right` 的起点就是 `mid` + 1，终点就是 `high`。对于子序列 `left` 和 `right` 递归地调用该函数，对于情形 3 遍历即可。
